# Stubs for polib (Python 3.x)
#

import textwrap
from typing import Any, AnyStr, Optional, Text, TextIO, Sequence, List, Mapping, Union, Tuple, Dict


class io:
    @staticmethod
    def open(fpath: Text,
             mode: Text = ...,
             encoding: Optional[Text] = ...
             ) -> TextIO: ...

__author__: Text
__version__: Text
__all__: Sequence[Text]
PY3: bool
default_encoding: Text
text_type = Text

def pofile(pofile: Text,
           **kwargs: Optional[Mapping[Text, Union[Text, int, bool]]]
           ) -> POFile: ...

def mofile(mofile: Text,
           **kwargs: Optional[Mapping[Text, Union[Text, int, bool]]]
           ) -> MOFile: ...

def detect_encoding(file: Text,
                    binary_mode: bool = ...
                    ) -> Text: ...

def escape(st: Text,
           ) -> Text: ...

def unescape(st: Text,
           ) -> Text: ...


class _BaseFile(list):
    fpath: Text = ...
    wrapwidth: int = ...
    encoding: Text = ...
    check_for_duplicates: bool = ...
    header: Text = ...
    metadata: Dict[Text, Text] = ...
    metadata_is_fuzzy: int = ...
    def __init__(self, *args: Optional[Sequence[Union[Text, int, bool]]],
                 **kwargs: Optional[Mapping[Text, Union[Text, int, bool]]]
                 ) -> None: ...

    def __unicode__(self) -> Text: ...

    def __str__(self) -> Text: ...

    def __contains__(self,
                     entry: object
                     ) -> bool: ...

    def __eq__(self,
               other: Any
               ) -> bool: ...

    def append(self,
               entry: _BaseEntry
               ) -> None: ...

    def insert(self,
               index: int,
               entry: _BaseEntry) -> None: ...

    def metadata_as_entry(self) -> POFile: ...

    def save(self,
             fpath: Optional[Text] = ...,
             repr_method: Text = ...) -> None: ...

    def find(self, st: Text,
             by: Text = ...,
             include_obsolete_entries: bool = ...,
             msgctxt: bool = ...
             ) -> Optional[POEntry]: ...

    def ordered_metadata(self) -> Sequence[Tuple[Text, Text]]: ...

    def to_binary(self) -> Text: ...

    def _encode(self,
                mixed: Text
                ) -> Text: ...


class POFile(_BaseFile):
    def __unicode__(self) -> Text: ...

    def save_as_mofile(self,
                       fpath: Text
                       ) -> None: ...

    def percent_translated(self) -> int: ...

    def translated_entries(self) -> Sequence[_BaseEntry]: ...

    def untranslated_entries(self) -> Sequence[_BaseEntry]: ...

    def fuzzy_entries(self) -> Sequence[_BaseEntry]: ...

    def obsolete_entries(self) -> Sequence[_BaseEntry]: ...

    def merge(self,
              refpot: POFile
              ) -> None: ...


class MOFile(_BaseFile):
    MAGIC: int = ...
    MAGIC_SWAPPED: int = ...
    magic_number: Optional[int] = ...
    version: int = ...
    def __init__(self,
                 *args: Optional[Sequence[Union[Text, int, bool]]],
                 **kwargs: Optional[Mapping[Text, Union[Text, int, bool]]]
                 ) -> None: ...

    def save_as_pofile(self,
                       fpath: Text
                       ) -> None: ...

    def save(self,
             fpath: Optional[Text] = ...,
             repr_method: Text = ...
             ) -> None: ...

    def percent_translated(self) -> int: ...

    def translated_entries(self) -> MOFile: ...

    def untranslated_entries(self) -> Sequence[_BaseEntry]: ...

    def fuzzy_entries(self) -> Sequence[_BaseEntry]: ...

    def obsolete_entries(self) -> Sequence[_BaseEntry]: ...


class _BaseEntry:
    msgid: Optional[Text] = ...
    msgstr: Optional[Text] = ...
    msgid_plural: Optional[Text] = ...
    msgstr_plural: Sequence[Optional[Text]] = ...
    msgctxt: Optional[Text] = ...
    obsolete: Union[int, bool] = ...
    encoding: Optional[Text] = ...
    def __init__(self,
                 *args: Optional[Sequence[Union[Text, int, bool, Sequence]]],
                 **kwargs: Optional[Mapping[Text, Union[Text, int, bool, Sequence]]]
                 ) -> None: ...

    def __unicode__(self,
                    wrapwidth: int = ...
                    ) -> Text: ...

    def __str__(self) -> Text: ...

    def __eq__(self,
               other: Any
               ) -> bool: ...

    def _str_field(self,
                   fieldname: Text,
                   delflag: Text,
                   plural_index: Text,
                   field: Text,
                   wrapwidth: int = ...
                   ) -> Sequence[Text]: ...


class POEntry(_BaseEntry):
    comment: Text = ...
    tcomment: Text = ...
    occurrences: Sequence[Tuple[Text, Text]] = ...
    flags: Sequence[Text] = ...
    previous_msgctxt: Optional[Text] = ...
    previous_msgid: Optional[Text] = ...
    previous_msgid_plural: Optional[Text] = ...
    linenum: Optional[int] = ...
    msgid: Optional[Text] = ...
    msgctxt: Optional[Text] = ...
    msgid_plural: Optional[Text] = ...
    obsolete: Union[int, bool] = ...
    def __init__(self,
                 *args: Optional[Sequence[Union[Text, int, bool, Sequence]]],
                 **kwargs: Optional[Mapping[Text, Union[Text, int, bool, Sequence]]]
                 ) -> None: ...

    def __unicode__(self,
                    wrapwidth: int = ...
                    ) -> Text: ...

    def __cmp__(self,
                other: Any
                ) -> int: ...

    def __gt__(self,
               other: Any
               ) -> bool: ...

    def __lt__(self,
               other: Any
               ) -> bool: ...

    def __ge__(self,
               other: Any
               ) -> bool: ...

    def __le__(self,
               other: Any
               ) -> bool: ...

    def __eq__(self,
               other: Any
               ) -> bool: ...

    def __ne__(self,
               other: Any
               ) -> bool: ...

    def __hash__(self) -> int: ...

    def translated(self) -> bool: ...

    def merge(self,
              other: _BaseEntry
              ) -> None: ...

    @property
    def fuzzy(self) -> bool: ...

    @property
    def msgid_with_context(self) -> Text: ...


class MOEntry(_BaseEntry):
    comment: Text = ...
    tcomment: Text = ...
    occurrences: Sequence[Tuple[Text, Text]] = ...
    flags: Sequence[Text] = ...
    previous_msgctxt: Optional[Text] = ...
    previous_msgid: Optional[Text] = ...
    previous_msgid_plural: Optional[Text] = ...
    def __init__(self,
                 *args: Optional[Sequence[Union[Text, int, bool, Sequence]]],
                 **kwargs: Optional[Mapping[Text, Union[Text, int, bool, Sequence]]]
                 ) -> None: ...
    def __hash__(self) -> int: ...


class _POFileParser:
    fhandle: Text = ...
    instance: _BaseFile = ...
    transitions: Mapping[Tuple[Text, Text], Tuple[Text, Text]] = ...
    current_line: int = ...
    current_entry: _BaseEntry = ...
    current_state: Text = ...
    current_token: Optional[Text] = ...
    msgstr_index: int = ...
    entry_obsolete: int = ...
    def __init__(self,
                 pofile: Text,
                 *args: Optional[Sequence[Union[Text, bool]]],
                 **kwargs: Optional[Mapping[Text, Union[Text, bool]]]
                 ) -> None: ...

    def parse(self) -> _BaseFile: ...

    def add(self,
            symbol: Text,
            states: Sequence[Text],
            next_state: Text
            ) -> None: ...

    def process(self,
                symbol: Text
                ) -> None: ...

    def handle_he(self) -> int: ...
    def handle_tc(self) -> bool: ...
    def handle_gc(self) -> bool: ...
    def handle_oc(self) -> bool: ...
    def handle_fl(self) -> bool: ...
    def handle_pp(self) -> bool: ...
    def handle_pm(self) -> bool: ...
    def handle_pc(self) -> bool: ...
    def handle_ct(self) -> bool: ...
    def handle_mi(self) -> bool: ...
    def handle_mp(self) -> bool: ...
    def handle_ms(self) -> bool: ...
    def handle_mx(self) -> bool: ...
    def handle_mc(self) -> bool: ...


class _MOFileParser:
    fhandle: TextIO = ...
    instance: _BaseFile = ...
    def __init__(self,
                 mofile: Text,
                 *args: Optional[Sequence[Union[Text, bool]]],
                 **kwargs: Optional[Mapping[Text, Union[Text, bool]]]
                 ) -> None: ...

    def __del__(self) -> None: ...

    def parse(self) -> _BaseFile: ...

    def _build_entry(self,
                     msgid: Text,
                     msgstr: Optional[Text] = ...,
                     msgid_plural: Optional[Text] = ...,
                     msgstr_plural: Optional[Sequence[Text]] = ...
                     ) -> _BaseEntry: ...

    def _readbinary(self,
                    fmt: Text,
                    numbytes: int
                    ) -> Tuple[Text]: ...

class TextWrapper(textwrap.TextWrapper):
    drop_whitespace: bool = ...
    def __init__(self,
                 *args: Optional[Sequence[Union[Text, int, bool]]],
                 **kwargs: Optional[Mapping[Text, Union[Text, int, bool]]]
                 ) -> None: ...

    def _wrap_chunks(self,
                     chunks: Sequence[Text]
                     ) -> List[AnyStr]: ...
